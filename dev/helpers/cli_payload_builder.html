<!-- Generated by GitHub Copilot on 2025-11-12 at user request.
  Purpose: Visual helper to assemble CLI payload bytes from sanbot_mcu.sqlite.
  Location: dev/helpers/cli_payload_builder.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sanbot MCU CLI Payload Builder</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 1.5rem; }
    header { margin-bottom: 1rem; }
    fieldset { border: 1px solid #ccc; border-radius: 6px; margin-bottom: 1rem; }
    legend { padding: 0 .5rem; font-weight: 600; }
    label { font-weight: 600; }
    .row { display: flex; align-items: center; gap: .75rem; margin: .5rem 0; }
    .grow { flex: 1 1 auto; }
    table { border-collapse: collapse; width: 100%; margin-top: .5rem; }
    th, td { border: 1px solid #ddd; padding: .4rem .5rem; }
    th { background: #f6f8fa; text-align: left; }
    code { background: #f6f8fa; padding: 0 .25rem; border-radius: 3px; }
    .out { background: #0b1020; color: #e8eaff; padding: .75rem; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; overflow-x: auto; }
    .btn { padding: .4rem .7rem; border-radius: 6px; border: 1px solid #999; background: #fff; cursor: pointer; }
    .btn.primary { background: #1f883d; border-color: #1f883d; color: white; }
    .hint { color: #666; font-size: .9rem; }
  </style>
  <!-- sql.js v1.10.2 from jsdelivr CDN -->
  <script src="https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/sql-wasm.js"></script>
</head>
<body>
  <header>
    <h1>Sanbot MCU CLI Payload Builder</h1>
    <p class="hint">Load <code>dev/analysis/mcu_sql/sanbot_mcu.sqlite</code>, pick a command by <code>api_name</code> (or <code>cmd_id</code>), enter payload values, and get the final bytes.</p>
  </header>

  <fieldset>
    <legend>1. Load database</legend>
    <div class="row">
      <input id="dbfile" type="file" accept=".sqlite,.db,.sqlite3,application/octet-stream" />
      <button class="btn" id="btnLoadSample" title="Try loading from repo path (may not work due to browser restrictions)">Try load from repo path</button>
      <span id="dbStatus" class="hint"></span>
    </div>
  </fieldset>

  <fieldset>
    <legend>2. Pick command</legend>
    <div class="row">
      <label for="cmdSelect">Command:</label>
      <select id="cmdSelect" class="grow" disabled></select>
      <button class="btn" id="btnRefresh" disabled>Refresh</button>
    </div>
    <div id="cmdMeta" class="hint"></div>
  </fieldset>

  <fieldset>
    <legend>3. Enter payload values</legend>
    <div class="hint">Header bytes from DB: <code id="hdrBytes">—</code></div>
    <table id="payloadTable">
      <thead>
        <tr><th>#</th><th>Label</th><th>Type</th><th>Value</th></tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="row">
      <button class="btn primary" id="btnAssemble" disabled>Assemble Bytes</button>
      <span class="hint">Types supported: u8/i8/u16le/u16be/i16le/u32le/u32be/float32le/float32be. Or enter hex like <code>0xFF</code> or <code>AA BB CC</code>.</span>
    </div>
  </fieldset>

  <fieldset>
    <legend>4. Output</legend>
    <div class="row">
      <button class="btn" id="btnCopyHex" disabled>Copy Hex</button>
      <button class="btn" id="btnCopyArray" disabled>Copy Uint8Array</button>
    </div>
    <div class="out" id="outHex">—</div>
    <div class="out" id="outArray">—</div>
  </fieldset>

  <script>
    // Utility: hex helpers
    function hexByte(n){ return n.toString(16).padStart(2, '0'); }
    function parseHexStringToBytes(str){
      // Accept formats: "0xAA", "AA BB CC", "aa-bb-cc"
      const bytes = [];
      const cleaned = str.trim().replace(/[-_,]/g, ' ').replace(/\s+/g, ' ');
      if(/^0x[0-9a-fA-F]+$/.test(cleaned)){
        const s = cleaned.slice(2);
        for(let i=0;i<s.length;i+=2){ bytes.push(parseInt(s.slice(i, i+2), 16)); }
        return bytes;
      }
      cleaned.split(' ').forEach(tok => {
        if(tok){ bytes.push(parseInt(tok, 16)); }
      });
      return bytes;
    }

    function packByType(value, type){
      // value can be number or hex string
      if(typeof value === 'string' && value.trim()){
        // if hex-looking, return raw bytes
        if(/^(0x[0-9a-fA-F]+|[0-9a-fA-F]{2}(?:\s+[0-9a-fA-F]{2})+)$/.test(value.trim())){
          return parseHexStringToBytes(value);
        }
      }
      const n = Number(value);
      if(!Number.isFinite(n)) throw new Error(`Invalid numeric value: ${value}`);

      const dv = new DataView(new ArrayBuffer(8));
      const out = [];
      const t = (type||'u8').toLowerCase();
      switch(t){
        case 'u8': out.push(n & 0xFF); break;
        case 'i8': out.push((n & 0xFF) >>> 0); break;
        case 'u16le': dv.setUint16(0, n, true); out.push(dv.getUint8(0), dv.getUint8(1)); break;
        case 'u16be': dv.setUint16(0, n, false); out.push(dv.getUint8(0), dv.getUint8(1)); break;
        case 'i16le': dv.setInt16(0, n, true); out.push(dv.getUint8(0), dv.getUint8(1)); break;
        case 'u32le': dv.setUint32(0, n, true); out.push(dv.getUint8(0), dv.getUint8(1), dv.getUint8(2), dv.getUint8(3)); break;
        case 'u32be': dv.setUint32(0, n, false); out.push(dv.getUint8(0), dv.getUint8(1), dv.getUint8(2), dv.getUint8(3)); break;
        case 'float32le': dv.setFloat32(0, n, true); out.push(dv.getUint8(0), dv.getUint8(1), dv.getUint8(2), dv.getUint8(3)); break;
        case 'float32be': dv.setFloat32(0, n, false); out.push(dv.getUint8(0), dv.getUint8(1), dv.getUint8(2), dv.getUint8(3)); break;
        default:
          // fallback assume u8
          out.push(n & 0xFF);
      }
      return out;
    }

    function parseHexBytePair(str){
      if(!str) return [];
      const s = str.toLowerCase().replace(/0x/g, '').replace(/\s+/g, '');
      if(s.length % 2 !== 0) throw new Error('Hex must be in full bytes');
      const out = [];
      for(let i=0;i<s.length;i+=2){ out.push(parseInt(s.slice(i, i+2), 16)); }
      return out;
    }

    const E = sel => document.querySelector(sel);

    let SQL, db;

    async function initSQL(){
      SQL = await initSqlJs({ locateFile: file => `https://cdn.jsdelivr.net/npm/sql.js@1.10.2/dist/${file}` });
    }

    function loadDBFromFile(file){
      const reader = new FileReader();
      reader.onload = () => {
        const u8 = new Uint8Array(reader.result);
        db = new SQL.Database(u8);
        E('#dbStatus').textContent = `Loaded ${file.name} (${u8.length} bytes)`;
        refreshCommands();
      };
      reader.readAsArrayBuffer(file);
    }

    function tryLoadFromRepoPath(){
      // Attempt fetch; will fail on file:// without a local server
      fetch('../analysis/mcu_sql/sanbot_mcu.sqlite').then(r => r.arrayBuffer()).then(buf => {
        db = new SQL.Database(new Uint8Array(buf));
        E('#dbStatus').textContent = `Loaded from repo path (size ${buf.byteLength} bytes)`;
        refreshCommands();
      }).catch(() => {
        E('#dbStatus').textContent = 'Direct load blocked; use the file picker above.';
      });
    }

    function refreshCommands(){
      if(!db){ return; }
      const res = db.exec(`SELECT cmd_id, coalesce(api_name, '') AS api_name, coalesce(api_group, '') AS api_group, class_name, category, address_hex, command_mode_hex FROM commands ORDER BY cmd_id;`);
      const rows = (res[0] && res[0].values) || [];
      const sel = E('#cmdSelect');
      sel.innerHTML = '';
      rows.forEach(r => {
        const [cmd_id, api_name, api_group, class_name, category, address_hex, command_mode_hex] = r;
        const name = api_name || class_name || `cmd_${cmd_id}`;
        const opt = document.createElement('option');
        opt.value = String(cmd_id);
        opt.textContent = `${name}  (id=${cmd_id})  [${api_group || category || ''}]`;
        opt.dataset.address = address_hex || '';
        opt.dataset.mode = command_mode_hex || '';
        sel.appendChild(opt);
      });
      sel.disabled = rows.length === 0;
      E('#btnRefresh').disabled = false;
      E('#btnAssemble').disabled = rows.length === 0;
      E('#btnCopyHex').disabled = true;
      E('#btnCopyArray').disabled = true;
      if(rows.length){ sel.selectedIndex = 0; onSelectCommand(); }
    }

    function onSelectCommand(){
      const sel = E('#cmdSelect');
      const cmdId = Number(sel.value);
      const address = sel.options[sel.selectedIndex].dataset.address || '';
      const mode = sel.options[sel.selectedIndex].dataset.mode || '';
      E('#hdrBytes').textContent = `${address || '—'} ${mode || '—'}`.trim();

      // Load payload rows
      const res = db.exec(`SELECT byte_order, label, coalesce(source_type, '') as source_type, coalesce(description, '') as description FROM command_bytes WHERE cmd_id = ${cmdId} ORDER BY byte_order ASC;`);
      const rows = (res[0] && res[0].values) || [];
      const tbody = E('#payloadTable tbody');
      tbody.innerHTML = '';
      rows.forEach(([ord, label, type, desc]) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${ord}</td><td>${label||''}<div class="hint">${desc||''}</div></td><td>${type||''}</td><td><input class="val" data-type="${type||''}" placeholder="e.g. 255 or 0xFF or AA BB"/></td>`;
        tbody.appendChild(tr);
      });
    }

    function assemble(){
      const sel = E('#cmdSelect');
      const address = (sel.options[sel.selectedIndex].dataset.address || '').replace(/\s+/g, '');
      const mode = (sel.options[sel.selectedIndex].dataset.mode || '').replace(/\s+/g, '');
      const header = [];
      if(address){ header.push(...parseHexBytePair(address)); }
      if(mode){ header.push(...parseHexBytePair(mode)); }

      const inputs = Array.from(document.querySelectorAll('#payloadTable input.val'));
      const payload = [];
      for(const inp of inputs){
        const type = inp.dataset.type || 'u8';
        const val = inp.value.trim();
        if(!val){
          // default zero of appropriate size
          payload.push(...packByType(0, type));
        } else {
          payload.push(...packByType(val, type));
        }
      }

      const all = [...header, ...payload];
      const hex = all.map(b => hexByte(b)).join(' ').toUpperCase();
      E('#outHex').textContent = hex || '—';
      E('#outArray').textContent = `Uint8Array([${all.join(', ')}])`;
      E('#btnCopyHex').disabled = all.length === 0;
      E('#btnCopyArray').disabled = all.length === 0;
    }

    function copyText(id){
      const txt = E(id).textContent;
      navigator.clipboard.writeText(txt || '').then(()=>{
        const btn = (id==='#outHex')?E('#btnCopyHex'):E('#btnCopyArray');
        const old = btn.textContent; btn.textContent = 'Copied!'; setTimeout(()=>btn.textContent=old, 900);
      });
    }

    // Wire up UI
    (async function(){
      await initSQL();
      E('#dbfile').addEventListener('change', e => {
        const f = e.target.files && e.target.files[0];
        if(f) loadDBFromFile(f);
      });
      E('#btnLoadSample').addEventListener('click', tryLoadFromRepoPath);
      E('#btnRefresh').addEventListener('click', refreshCommands);
      E('#cmdSelect').addEventListener('change', onSelectCommand);
      E('#btnAssemble').addEventListener('click', assemble);
      E('#btnCopyHex').addEventListener('click', () => copyText('#outHex'));
      E('#btnCopyArray').addEventListener('click', () => copyText('#outArray'));
    })();
  </script>
</body>
</html>
